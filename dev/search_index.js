var documenterSearchIndex = {"docs":
[{"location":"diffeqn/#Algorithm-to-solve-Differential-equations","page":"Algorithm to solve Differential equations","title":"Algorithm to solve Differential equations","text":"","category":"section"},{"location":"diffeqn/#Euler-Method","page":"Algorithm to solve Differential equations","title":"Euler Method","text":"","category":"section"},{"location":"diffeqn/#4th-order-Runge-Kutta-Method","page":"Algorithm to solve Differential equations","title":"4th order Runge-Kutta Method","text":"","category":"section"},{"location":"diffeqn/#UsefulFunctions.euler","page":"Algorithm to solve Differential equations","title":"UsefulFunctions.euler","text":"Solves (system of) Ordinary differential equations using the Euler method.     function euler(F,x0,t1,t2,n,p)\n\nArgs:     F (function): Function that returns the derivatives of the state vector.     x0 (array): Initial state vector.     t1 (float): Initial time.     t2 (float): Final time.     n (int): Number of steps.     p (array): Parameters.\n\n\n\n\n\n","category":"function"},{"location":"diffeqn/#UsefulFunctions.rk4","page":"Algorithm to solve Differential equations","title":"UsefulFunctions.rk4","text":"Solves (system of) Ordinary differential equations using the Runge-Kutta method.     function rk4(F,x0,t1,t2,n,p)\n\nArgs:     F (function): Function that returns the derivatives of the state vector.     x0 (array): Initial state vector.     t1 (float): Initial time.     t2 (float): Final time.     n (int): Number of steps.     p (array): Parameters.\n\n\n\n\n\n","category":"function"},{"location":"integration/#Integration-Routines","page":"Integration Routines","title":"Integration Routines","text":"In most cases I use pacakges like QuadGK or Cubature and HCubature for numerical integration in Julia. However, sometimes I need to use simple integration routines for quick calculations. Here are such routines ","category":"section"},{"location":"integration/#Principal-Value-Integration","page":"Integration Routines","title":"Principal Value Integration","text":"","category":"section"},{"location":"integration/#UsefulFunctions.trapizoid","page":"Integration Routines","title":"UsefulFunctions.trapizoid","text":"trapizoid(f::Function, a::Float64, b::Float64, n::Int64)\n\nReturns the integral of f from a to b using the trapezoidal rule with n steps.\n\n\n\n\n\n","category":"function"},{"location":"integration/#UsefulFunctions.simpson","page":"Integration Routines","title":"UsefulFunctions.simpson","text":"simpson(f::Function, a::Float64, b::Float64, n::Int64)\n\nReturns the integral of f from a to b using Simpson's rule with n steps.\n\n\n\n\n\n","category":"function"},{"location":"integration/#UsefulFunctions.PVintegral","page":"Integration Routines","title":"UsefulFunctions.PVintegral","text":"PVintegral(f::Function, a, b, c, integrate::Function)\n\nCalculates the Cauchy principal value integral ∫ₐᵇf(x)/(x-c)dx First it turns into a symmetric integral from -1 to 1, then substracts the singulatity. It uses the function integrate to calculate all the finite integrals.\n\n\n\n\n\n","category":"function"},{"location":"indices/#List-of-Functions","page":"Indices","title":"List of Functions","text":"List of the functions available\n\nOrder = [:function]","category":"section"},{"location":"miscellaneous/#Miscellaneous-Functions","page":"Miscellaneous Functions","title":"Miscellaneous Functions","text":"","category":"section"},{"location":"miscellaneous/#Number-Distribution","page":"Miscellaneous Functions","title":"Number Distribution","text":"","category":"section"},{"location":"miscellaneous/#Convinience-constructions","page":"Miscellaneous Functions","title":"Convinience constructions","text":"","category":"section"},{"location":"miscellaneous/#Unorganized","page":"Miscellaneous Functions","title":"Unorganized","text":"","category":"section"},{"location":"miscellaneous/#UsefulFunctions.numberF","page":"Miscellaneous Functions","title":"UsefulFunctions.numberF","text":"numberF(temp::Float64, μ::Float64, Energy::Float64)\n\nReturns the number density at a given Energy, chemical potential μ and temp for Fermionic Species.\n\n\n\n\n\n","category":"function"},{"location":"miscellaneous/#UsefulFunctions.numberB","page":"Miscellaneous Functions","title":"UsefulFunctions.numberB","text":"numberB(temp::Float64, μ::Float64, Energy::Float64)\n\nReturns the number density at a given Energy, chemical potential μ and temp for Bosonic Species.\n\n\n\n\n\n","category":"function"},{"location":"miscellaneous/#UsefulFunctions.DiracDelta","page":"Miscellaneous Functions","title":"UsefulFunctions.DiracDelta","text":"DiracDelta(input::Float64,δ::Float64 = 1e-3)\n\nDirac Delta Function that can be used in a numerical integration.\n\n\n\n\n\n","category":"function"},{"location":"miscellaneous/#UsefulFunctions.PrincipalValue","page":"Miscellaneous Functions","title":"UsefulFunctions.PrincipalValue","text":"PrincipalValue(x::Float64,ϵ::Float64 = 1e-3)\n\nUseful function in Principal Value Integration.\n\n\n\n\n\n","category":"function"},{"location":"miscellaneous/#UsefulFunctions.fzero","page":"Miscellaneous Functions","title":"UsefulFunctions.fzero","text":"fzero(func::Function, start::Float64, finish::Float64, iteration::Int64=20)\n\nReturns the value of the argument between start and finish where the given function func becomes zero using midpoint method.\n\n\n\n\n\n","category":"function"},{"location":"miscellaneous/#UsefulFunctions.threaded_loop","page":"Miscellaneous Functions","title":"UsefulFunctions.threaded_loop","text":"threaded_loop(iter, func_eval)\n\nThis function returns loops over the iter and evaluate the function func_eval for each value in multiple threads and returns an array of result.\n\n\n\n\n\n","category":"function"},{"location":"miscellaneous/#UsefulFunctions._terms","page":"Miscellaneous Functions","title":"UsefulFunctions._terms","text":"terms(f::Function,Λ::Float64,n::Int64)\n\nReturns the terms for the separable representation of the function f given by f(p,p') = ∑ᵢ gᵢ(p)gᵢ(p') where gᵢ are the terms returned by this function.\n\nArguments\n\nf::Function: The function to be represented.\nΛ::Float64: Momentum cutoff.\nn::Int64: Number of terms in approximation to be returned.\n\n\n\n\n\n","category":"function"},{"location":"root_finding/#Root-Finding-Algorithms","page":"Root Finding","title":"Root Finding Algorithms","text":"","category":"section"},{"location":"root_finding/#Bisection-Method","page":"Root Finding","title":"Bisection Method","text":"","category":"section"},{"location":"root_finding/#Newton's-Method","page":"Root Finding","title":"Newton's Method","text":"","category":"section"},{"location":"root_finding/#Brent's-Method","page":"Root Finding","title":"Brent's Method","text":"","category":"section"},{"location":"root_finding/#Broyden's-Method","page":"Root Finding","title":"Broyden's Method","text":"","category":"section"},{"location":"root_finding/#UsefulFunctions.bisection","page":"Root Finding","title":"UsefulFunctions.bisection","text":"bisection(func::Function,start::Number,finish::Number,iteration::Integer=20)\n\nFinds the zero of a function func inside a given interval (start,finish). Might fail  if there are multiple zeros or no zeros inside the interval.\n\n\n\n\n\n","category":"function"},{"location":"root_finding/#UsefulFunctions.NewtonMethod","page":"Root Finding","title":"UsefulFunctions.NewtonMethod","text":"NewtonMethod(func::Function, Jacobian::Function,initial_guess::Array,iteration=100)\n\nuses the Newton method toi find zeros in more than one dimensions. x_n+1 = x_n - J^-1(x_n)f(x_n)\n\n\n\n\n\n","category":"function"},{"location":"root_finding/#UsefulFunctions.NewtonRaphson","page":"Root Finding","title":"UsefulFunctions.NewtonRaphson","text":"NewtonRaphson(f::Function,initial_guess;tol=1e-3,ϵ=1e-3,maxiter=20)\n\nUses Newton Raphson Method to find zero of a given function f starting from an initial_guess.\n\nx_n+1 = x_n - fracf(x_n)f(x_n)\n\nwhere discreet derivatives are used when functional form of the derivative are not given as input.\n\n\n\n\n\n","category":"function"},{"location":"root_finding/#UsefulFunctions.brent","page":"Root Finding","title":"UsefulFunctions.brent","text":"brent(f::Function, x0::Number, x1::Number, args::Tuple=(); xtol::AbstractFloat=1e-4, ytol=1e-6, maxiter::Integer=20)\n\nThe function uses Brent's Method to find zero inside the given interval (x0,x1). Might fail if there are multiple zeros inside the interval.\n\n\n\n\n\n","category":"function"},{"location":"root_finding/#UsefulFunctions.broyden","page":"Root Finding","title":"UsefulFunctions.broyden","text":"broyden(fun, jaco, x, iter=50, ftol=1e-7, verbose=false)\n\nUses Broyden's method to find zero of a multidimensional function.\n\n\n\n\n\n","category":"function"},{"location":"filters/#Filters","page":"Filters","title":"Filters","text":"Collection of different filters to smoothen data. For examples,\n\nThere are also a few numerical differentiation routine using filters,","category":"section"},{"location":"filters/#UsefulFunctions.savitzky_golay_filter_53","page":"Filters","title":"UsefulFunctions.savitzky_golay_filter_53","text":"savitzky_golay_filter_53(data::Vector{Float64})\n\nApplies a 5-point, 3rd-order Savitzky-Golay filter to the input data vector.\n\n\n\n\n\n","category":"function"},{"location":"filters/#UsefulFunctions.moving_average_filter","page":"Filters","title":"UsefulFunctions.moving_average_filter","text":"moving_average_filter(data::Vector{Float64}, window_size::Int)\n\nApplies a moving average filter to the input data vector with the specified window size.\n\n\n\n\n\n","category":"function"},{"location":"filters/#UsefulFunctions._derivative","page":"Filters","title":"UsefulFunctions._derivative","text":"_derivative(f, x; h=1e-2)\n\nComputes the first derivative of function f at point x using a five-point stencil method.\n\n\n\n\n\n","category":"function"},{"location":"filters/#UsefulFunctions._second_derivative","page":"Filters","title":"UsefulFunctions._second_derivative","text":"_second_derivative(f, x; dx=1e-2)\n\nComputes the second derivative of function f at point x using central difference method.\n\n\n\n\n\n","category":"function"},{"location":"filters/#UsefulFunctions._sg_filter_second_derivative","page":"Filters","title":"UsefulFunctions._sg_filter_second_derivative","text":"_sg_filter_second_derivative(f, x; dx=1e-2)\n\nComputes the second derivative of function f at point x using a Savitzky-Golay filter. See wikipedia for details.\n\n\n\n\n\n","category":"function"},{"location":"filters/#UsefulFunctions._first_derivative_smooth","page":"Filters","title":"UsefulFunctions._first_derivative_smooth","text":"_first_derivative_smooth(f, x; dx=1e-2)\n\nComputes a smoothed first derivative of function f at point x using a Savitzky-Golay filter. See wikipedia for details.\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#Interpolations","page":"Interpolations","title":"Interpolations","text":"This module provides various interpolation methods for one-dimensional data. The available interpolation methods include:","category":"section"},{"location":"interpolation/#Pade-Approximation","page":"Interpolations","title":"Pade Approximation","text":"","category":"section"},{"location":"interpolation/#UsefulFunctions.interp","page":"Interpolations","title":"UsefulFunctions.interp","text":"function interp(n::Int64,list::Array)\n\nThis function returns the interpolated function between 0 and 1 given an Array.\n\n\n\n\n\n","category":"function"},{"location":"interpolation/#UsefulFunctions.pade_approximation","page":"Interpolations","title":"UsefulFunctions.pade_approximation","text":"pade_approximation(x_values, f_values, m, n)\n\nReturns pade approximation given two vectors, the xvalues and the function evaluated at those points fvalues\n\n\n\n\n\n","category":"function"},{"location":"#Useful-Functions","page":"Home","title":"Useful Functions","text":"\n\nA package containing some of the functions that I regularly use in my code. Not an exhaustive list. But I use this package as a dependency in many of my other bigger projects.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install the package, use the following command in the Julia REPL:\n\nimport Pkg\nPkg.add(url=\"https://github.com/biplab37/UsefulFunctions.jl\")\n\nor press ] to enter the package manager and run:\n\nadd https://github.com/biplab37/UsefulFunctions.jl","category":"section"},{"location":"#List-of-Available-Functions","page":"Home","title":"List of Available Functions","text":"Root Finding Algorithms\nSolving Differential Equations\nFilters and Derivatives\nNumerical Integration\nInterpolation\nMiscellaneous Functions","category":"section"}]
}
